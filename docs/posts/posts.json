[
  {
    "path": "posts/2021-09-11-benchmarking_binary_predicates/",
    "title": "Benchmarking binary predicates",
    "description": "Comparing the speeds of different methods to do a \"point in polygon operation\" with sf.",
    "author": [
      {
        "name": "Nils Ratnaweera",
        "url": {}
      }
    ],
    "date": "2021-09-11",
    "categories": [
      "R",
      "geodata"
    ],
    "contents": "\nI often come across a situation where I need to subset points based on whether they lie within a polygon or not. There are several methods to solve this problem.1 In sf the functions st_within, st_contains, st_intersects or st_covered_by lead you to similar results.2\nWith big datasets, some of these functions are unbearably slow. To find out which one is faster in which scenario, I decided to benchmark the four functions.\nTo make things a bit more interesting, I won’t use my usual Swiss data for this test, but data from my second home, Sri Lanka. More specifically: I will use the “Geonames” data (> 50k Points, obtained from here) and the administrative boundaries of Sri Lanka (“province”, obtained from here).\n\n\nshow code for: loading libraries\n\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(sf)\nlibrary(readr)\nlibrary(ggplot2)\n\n\n\n\n\nshow code for: preparing boundary data\n\n# Downloaded from: https://data.humdata.org/dataset/sri-lanka-administrative-levels-0-4-boundaries\n# Administrative Level 0: country (1 features)\n# Administrative Level 1: province (9 features)\n# Administrative Level 2: district (26 features)\n# Administrative Level 3: divisional secretatiat (333 features)\n# Administrative Level 4: grama niladhari (14'044 features)\n\ntmp <- tempdir()\n\nboundary_dir <- file.path(tmp, \"boundary\")\nunzip(\"data-git-lfs/lka_adm_slsd_20200305_shp.zip\", exdir = boundary_dir)\n\nsl_boundary_l2 <- read_sf(\n  file.path(boundary_dir, \"lka_admbnda_adm2_slsd_20200305.shp\")\n  )\n# https://epsg.io/5234\n# https://epsg.io/5235\n\n\n\n\n\nshow code for: preparing geonames dataset\n\n# geonameid         : integer id of record in geonames database\n# name              : name of geographical point (utf8) varchar(200)\n# asciiname         : name of geographical point in plain ascii characters, varchar(200)\n# alternatenames    : alternatenames, comma separated, ascii names automatically transliterated, convenience attribute from alternatename table, varchar(10000)\n# latitude          : latitude in decimal degrees (wgs84)\n# longitude         : longitude in decimal degrees (wgs84)\n# feature class     : see http://www.geonames.org/export/codes.html, char(1)\n# feature code      : see http://www.geonames.org/export/codes.html, varchar(10)\n# country code      : ISO-3166 2-letter country code, 2 characters\n# cc2               : alternate country codes, comma separated, ISO-3166 2-letter country code, 200 characters\n# admin1 code       : fipscode (subject to change to iso code), see exceptions below, see file admin1Codes.txt for display names of this code; varchar(20)\n# admin2 code       : code for the second administrative division, a county in the US, see file admin2Codes.txt; varchar(80) \n# admin3 code       : code for third level administrative division, varchar(20)\n# admin4 code       : code for fourth level administrative division, varchar(20)\n# population        : bigint (8 byte int) \n# elevation         : in meters, integer\n# dem               : digital elevation model, srtm3 or gtopo30, average elevation of 3''x3'' (ca 90mx90m) or 30''x30'' (ca 900mx900m) area in meters, integer. srtm processed by cgiar/ciat.\n# timezone          : the iana timezone id (see file timeZone.txt) varchar(40)\n# modification date : date of last modification in yyyy-MM-dd format\n\n\ncolnames <- c(\"geonameid\", \"name\",  \"asciiname\",  \"alternatenames\", \"latitude\",  \"longitude\",  \"feature_class\",  \"feature_code\", \"country_code\",  \"cc2\",  \"admin1_code\",  \"admin2_code\",  \"admin3_code\",  \"admin4_code\",  \"population\", \"elevation\", \"dem\", \"timezone\",  \"modification_date\")\n\n\ngeonames_dir <- file.path(tmp, \"geonames\")\n\nunzip(\"data-git-lfs/LK.zip\", exdir = geonames_dir)\n\ngeonames <- read_tsv(file.path(geonames_dir, \"LK.txt\"),col_names = colnames) %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs = 4326)\n\n\n\nOnce all the data is imported, I can demonstrate visually the task. I want to subset all points within the province of Kandy (where I coincidentally spent 5 superb years of my childhood). Using st_within() for this operation, the output looks like this:\n\n\n\nshow code for: subsetting and creating a map\n\nkandy <- filter(sl_boundary_l2, ADM2_EN == \"Kandy\")\nfilter1 <- geonames[st_within(geonames,kandy,sparse = FALSE)[,1],]\n\n\np1 <- ggplot(sl_boundary_l2) + \n  geom_sf(color = \"#ffffff\", fill = \"#ababab\") +\n  geom_sf(data = rbind(transmute(geonames, val = \"all points\"), \n                       transmute(filter1, \n                                 val = \"points within the\\nprovince of Kandy\")), \n          alpha = 0.05, size = 0.05, color = \"#8d2663\") +\n  geom_sf(data = ~filter(., ADM2_EN == \"Kandy\"), fill = NA, color = \"#000000\") +\n  facet_wrap(~val) +\n  coord_sf(xlim = c(78, 83)) + \n  theme(strip.background = element_blank(),\n        strip.text = element_text(color = \"white\"),\n        panel.background = element_blank(),\n        plot.background = element_rect(fill = \"#2d2d2d\"),\n        panel.grid = element_blank(),\n        axis.text = element_blank(),\n        )\n\np1\n\n\n\n\nDoing the same operation as above with the other function is done as follows. In addition I will check the output number of rows to see if they are similar (they might be slightly off if we have points exactly on the polygon boundary) or even identical.\n\n\nfilter2 <- geonames[st_contains(kandy,geonames,sparse = FALSE)[1,],]\nfilter3 <- geonames[st_intersects(geonames,kandy,sparse = FALSE)[,1],]\nfilter4 <- geonames[st_covered_by(geonames,kandy,sparse = FALSE)[,1],]\n\nfilter_list <- list(filter1, filter2, filter3, filter4)\n\n\n\ntibble(\n  fun = paste0(\"st_\",c(\"within\",\"contains\",\"intersects\",\"covered_by\")),\n  nrow = sapply(filter_list, nrow),\n  identical = sapply(filter_list, function(x){identical(filter1, x)})\n) %>%\n  knitr::kable()\n\n\nfun\nnrow\nidentical\nst_within\n3251\nTRUE\nst_contains\n3251\nTRUE\nst_intersects\n3251\nTRUE\nst_covered_by\n3251\nTRUE\n\nTo find out which function does the job fastest, I use the package microbenchmark. Since it doesn’t always take the same amount of time to process the same function, each function is executed multiple times (times = 50).\n\n\nshow code for: Benchmarking the functions\n\nlibrary(microbenchmark)\nlibrary(ggridges)\nlibrary(forcats)\n\nmbm  <- microbenchmark(\n  intersects = st_intersects(kandy,geonames),\n  within = st_within(geonames,kandy),\n  contains = st_contains(kandy,geonames),\n  covered_by = st_covered_by(geonames,kandy),\n  times = 50\n)\n\nmbm$time <- microbenchmark:::convert_to_unit(mbm$time,\"t\")\n\np2 <- mbm %>%\n  mutate(\n    expr = fct_reorder(expr,time,median,.desc = TRUE)\n  ) %>%\n  ggplot(aes(time,expr,fill = ..x..)) +\n  geom_density_ridges_gradient(scale = 2, rel_min_height = 0.01) +\n  scale_fill_viridis_c(option = \"C\")  +\n  labs(y = \"Function\",x = paste0(\"Duration (in \",attr(mbm$time,\"unit\"),\")\")) +\n  theme_minimal() +\n  theme(legend.position=\"none\")\n\np2\n\n\n\n\nThis benchmark shows that st_contains and st_intersects executes faster than st_covered_by and st_within. The next question is: How do the functions scale and perform under different scenarios? I’ll test this by generating additional points to subset, and also by using more provinces than just Kandy.\n\n\nshow code for: Benchmarking scalability\n\nn_points_vec <- c(100e3,200e3,500e3)\nn_poly_vec <- c(1,9,17,26)\n\nmbm2 <- map_dfr(n_points_vec,function(n_points){\n  \n  points <- st_sample(sl_boundary_l2,n_points,what = \"centers\")\n\n  mbm_points <- map_dfr(n_poly_vec, function(n_poly){\n    \n    polygons <- sample_n(sl_boundary_l2, n_poly)\n    \n    mbm_poly <- microbenchmark(\n      intersects = st_intersects(polygons,points),\n      within = st_within(points,polygons),\n      contains = st_contains(polygons,points),\n      covered_by = st_covered_by(points,polygons),\n      times = 10\n      )\n    \n    mbm_poly$time <- microbenchmark:::convert_to_unit(mbm_poly$time,\"ms\")\n    \n    as_tibble(mbm_poly) %>%\n      mutate(n_poly = n_poly)\n  }) %>%\n    mutate(n_points = n_points)\n})\n\n\n\n\n\n\n\n\n\n\n\nshow code for: Visualizing results\n\nmbm2$time <- microbenchmark:::convert_to_unit(mbm2$time,\"t\")\nquartiles <- function(x) {\n  # tibble(x = quantile(x, c(.25,.5,.75)), probs = paste0(\"Q\",1:3))\n  \n  quantile(x, c(.25,.5,.75)) %>%\n    setNames(paste0(\"Q\",1:3)) %>%\n    as.list() %>%\n    as_tibble()\n  \n}\n\nmbm2 %>%\n  group_by(expr, n_poly, n_points) %>%\n  summarise(quartiles(time)) %>% \n  ungroup() %>%\n  # mutate(across(starts_with(\"n\"),as.character)) %>%\n  ggplot(aes(n_poly,Q2, color = expr, fill = expr)) +\n  geom_point() +\n  geom_ribbon(aes(ymin = Q1, ymax = Q3), alpha = 0.1, color = FALSE) +\n  geom_line()  +\n  scale_y_continuous(paste0(\"Duration (in \",attr(mbm$time,\"unit\"),\")\"),labels = scales::label_number_si()) +\n  scale_x_continuous(name = \"Number of Polygons\") +\n  facet_wrap(~n_points, labeller = labeller(n_points = ~paste0(as.integer(.x)/1e3, \"K points\")), scales = \"free_y\", ncol = 1) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\nThis test shows something interesting: While st_intersects and st_contains are faster than st_covered_by and st_within with a single polygon, they are quickly overtaken in speed by st_within and st_covered_by when the number of polygon grows. This effect is most dominant with a large amount of points. So the take home message for me is to use st_intersects or st_contains when I have a small number of polygons and st_covered_by when the number of polygons increases.\n\nespecially since I mostly don’t care what happens to point which lie exactly on the polygon edge↩︎\nst_within and st_contains will disregard points on a line, st_intersects and st_covered_by will include them↩︎\n",
    "preview": "posts/2021-09-11-benchmarking_binary_predicates/preview.jpg",
    "last_modified": "2021-09-11T22:28:49+02:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-08-13-minimalistic-topography/",
    "title": "Minimalistic topography",
    "description": "A beautiful way to visualize topography, inspired by Carla Martínez Sastre",
    "author": [
      {
        "name": "Nils Ratnaweera",
        "url": {}
      }
    ],
    "date": "2021-08-13",
    "categories": [
      "R",
      "geodata"
    ],
    "contents": "\n“So beautiful that it hurts”1 Bauhasaurus wrote in his tweet, posting an image by Carla Martínez Sastre. The artist had used a beautiful, clever and minimalistic way to visualize the topography of South America.\n\n \n\nThe way I understand it, Carla drew “horizontal” (latitudanal) elevation profiles at equal intervals over the continent and filled these elevation profiles to visualize not only the continent’s topography, but also implicitly showing it’s borders.\nI found this a very nice approach and tried recreating this idea with R for my home country, Switzerland. I’m quite happy with the result, however there is still a lot of room for improvement. I’ve packed the approach into generic functions, see below for the complete source code. Check below to see the source code.\n\n\n\nCreate some generic functions\n\n\n#' Create ridgelines from a digital elevation model (dhm)\n#'\n#' dhm: path to a dhm that can be imported using terra::rast\n#' n_lines: how many lines / polygons do you want to draw? Default is 50\n#' vspace: vertical space between lines, in units provided by the dhm. This overrides n_lines\n#' fac: How much of the space between the lines should be occupied by the hightest elevation?\n#' point_density: Density of the point samples used to extract elevation. Defaults to the inverse of the raster resolution\n#' geom_type: What should the output geometry type be? Can be LINESTRING or POLYGON\ncreate_ridges <- function(dhm, n_lines = 50, vspace = NULL, fac = 2, point_density = NULL, geom_type = \"LINESTRING\"){\n  \n  library(sf)\n  library(terra)\n  library(purrr)\n  \n  # extract the extent of the dhm as a vector\n  ex <- ext(dhm) %>%\n    as.vector()\n  \n  # If vspace is NULL (default), then vspace is calculated using n_lines\n  if(is.null(vspace)){\n    vspace <- (ex[\"ymax\"] - ex[\"ymin\"])/n_lines\n  }\n  \n  \n  point_density <- if(is.null(point_density)){1/terra::res(dhm)[2]}\n  \n  # Defines at what y-coordinates elevation should be extracted\n  heights <- seq(ex[\"ymin\"], ex[\"ymax\"], vspace)\n  \n  # calculates the x/y coordinates to extract points from the dhm\n  mypoints_mat <- map(heights, function(height){\n    matrix(c(ex[\"xmin\"], height, ex[\"xmax\"], height), ncol = 2, byrow = TRUE) %>%\n      st_linestring()\n  }) %>%\n    st_as_sfc() %>%\n    st_line_sample(density = point_density,type = \"regular\") %>%\n    st_as_sf() %>%\n    st_cast(\"POINT\") %>%\n    st_coordinates()\n  \n  \n  # extracts the elevation from the dhm\n  extracted <- terra::extract(dhm, mypoints_mat) %>% \n    cbind(mypoints_mat) %>% \n    as_tibble()\n  \n  # calculates the factor with which to multiply elevation, based on \"fac\" and the maximum elevation value\n  fac <- vspace*fac/max(extracted[,1], na.rm = TRUE)\n  \n  # calculates the coordinats of the ridge lines\n  coords <-extracted %>%\n    filter(!is.na(extracted[,1])) %>%\n    split(.$Y) %>%\n    imap(function(df, hig){\n      hig <- as.numeric(hig)\n      Y_new <- hig+pull(df[,1])*fac\n      matrix(c(df$X, Y_new), ncol = 2)\n    })\n\n  # creates LINESTRING or POLYGON, based on the \"geom_type\"\n  geoms <- if(geom_type == \"LINESTRING\"){\n    map(coords, ~st_linestring(.x))\n  } else if(geom_type == \"POLYGON\"){\n    imap(coords, function(x, hig){\n      hig <- as.numeric(hig)\n      \n      first <- head(x, 1)\n      first[,2] <- hig\n      last <- tail(x, 1)\n      last[,2] <- hig\n      \n      st_polygon(list(rbind(first, x, last, first)))\n    })\n  } else{\n    stop(paste0(\"This geom_type is not implemented:\",geom_type,\". geom_type must be 'LINESTRING' or 'POLYGON'\"))\n  }\n  \n  # adds the CRS to the output sfc\n  dhm_crs <- crs(dhm)\n  \n  if(dhm_crs == \"\") warning(\"dhm does not seem to have a CRS, therefore the output does not have a CRS assigned either.\")\n  \n  geoms %>%\n    st_sfc() %>%\n    st_set_crs(dhm_crs)\n  \n}\n\n# A helper function to creteate a polygon from the extent of a (dhm) raster\nst_bbox_rast <- function(rast_obj){\n  \n  library(terra)\n  library(sf)\n  \n  ex <- ext(dhm) %>%\n    as.vector()\n  \n  matrix(c(ex[1],ex[3],ex[1], ex[4],ex[2], ex[4],ex[2],ex[3],ex[1],ex[3]),ncol = 2, byrow = TRUE) %>%\n  list() %>%\n  st_polygon() %>% \n    st_sfc(crs = crs(rast_obj))\n}\n\n\n\nImport data and use the functions\n\n\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(ragg)\n\n\ndhm <- terra::rast(\"data-git-lfs/DHM25/DHM200.asc\")\ncrs(dhm) <- \"epsg:21781\"\n\n\nswitzerland_21781 <- sf::read_sf(\"data-git-lfs/swissboundaries/swissBOUNDARIES3D_1_3_TLM_LANDESGEBIET.shp\") %>%\n  st_union() %>%\n  st_transform(21781) \n\nmymask <- st_bbox_rast(dhm) %>%\n  st_buffer(5000) %>%\n  st_difference(switzerland_21781)\n\n\n\n\n\nsf_obj <- create_ridges(dhm,n_lines = 35, fac = 1.1,geom_type = \"POLYGON\")\n\nbg_color <- \"#27363B\"\nfg_color <- \"#EB4960\"\nfamily <- \"FreeMono\"\n\n\n\n\nbbox_switz <- st_bbox(switzerland_21781)\nbbox_switz_enlarge <- st_buffer(st_as_sfc(bbox_switz),50000)\nlims <- st_bbox(bbox_switz_enlarge)\nxlims =  lims[c(\"xmin\",\"xmax\")]\nylims = lims[c(\"ymin\",\"ymax\")]\n\nasp <- diff(ylims)/diff(xlims)\n\n\n\n\n\nmyplot <- ggplot(sf_obj) +\n  geom_sf(color = \"NA\", fill = fg_color)  + \n  geom_sf(data = mymask, color = \"NA\", fill = bg_color) +\n  # geom_sf(data = bbox_switz_enlarge, fill = \"NA\") +\n  ggtext::geom_richtext(aes(x = median(xlims), y = quantile(ylims,0.95), label = \"Topography of Switzerland\"), family = family, fill = NA, label.color = NA, hjust = 0.5, size = 6, color = fg_color)+\n  ggtext::geom_richtext(aes(x = median(xlims), y = ylims[\"ymin\"], label = \"Data from ©swisstopo<br>visualized by Nils Ratnaweera\"), family = family, fill = NA, label.color = NA, hjust = 0.5, size = 3.5, color = fg_color)+\n  theme_void() +\n  theme(plot.background = element_rect(fill = bg_color,color = NA)) +\n  coord_sf(datum = 21781,xlim =  xlims, ylim = ylims);\n\nmyplot\n\n\n\nggsave(\"minimalistic_topography.png\", myplot,dpi = 600, device = agg_png, width = 15, units = \"cm\")\n\n\n\n\nOriginal (Esp): “Tan linda que duele.”↩︎\n",
    "preview": "posts/2021-08-13-minimalistic-topography/minimalistic_topography.png",
    "last_modified": "2021-09-11T23:04:20+02:00",
    "input_file": {},
    "preview_width": 3543,
    "preview_height": 2787
  }
]
