[
  {
    "path": "posts/2021-08-13-minimalistic-topography/",
    "title": "Minimalistic topography",
    "description": "A beautiful way to visualize topography, inspired by Carla Martínez Sastre",
    "author": [
      {
        "name": "Nils Ratnaweera",
        "url": {}
      }
    ],
    "date": "2020-08-13",
    "categories": [
      "R",
      "geodata"
    ],
    "contents": "\n“So beautiful that it hurts”1 Bauhasaurus wrote in his tweet, posting an image by Carla Martínez Sastre. The artist had used a beautiful, clever and minimalistic way to visualize the topography of South America.\n\n \n\nThe way I understand it, Carla drew “horizontal” (latitudanal) elevation profiles at equal intervals over the continent and filled these elevation profiles to visualize not only the continent’s topography, but also implicitly showing it’s borders.\nI found this a very nice approach and tried recreating this idea with R for my home country, Switzerland. I’m quite happy with the result, however there is still a lot of room for improvement. I’ve packed the approach into generic functions, see below for the complete source code. Check below to see the source code.\n\n\n\nCreate some generic functions\n\n\n#' Create ridgelines from a digital elevation model (dhm)\n#'\n#' dhm: path to a dhm that can be imported using terra::rast\n#' n_lines: how many lines / polygons do you want to draw? Default is 50\n#' vspace: vertical space between lines, in units provided by the dhm. This overrides n_lines\n#' fac: How much of the space between the lines should be occupied by the hightest elevation?\n#' point_density: Density of the point samples used to extract elevation. Defaults to the inverse of the raster resolution\n#' geom_type: What should the output geometry type be? Can be LINESTRING or POLYGON\ncreate_ridges <- function(dhm, n_lines = 50, vspace = NULL, fac = 2, point_density = NULL, geom_type = \"LINESTRING\"){\n  \n  library(sf)\n  library(terra)\n  library(purrr)\n  \n  # extract the extent of the dhm as a vector\n  ex <- ext(dhm) %>%\n    as.vector()\n  \n  # If vspace is NULL (default), then vspace is calculated using n_lines\n  if(is.null(vspace)){\n    vspace <- (ex[\"ymax\"] - ex[\"ymin\"])/n_lines\n  }\n  \n  \n  point_density <- if(is.null(point_density)){1/terra::res(dhm)[2]}\n  \n  # Defines at what y-coordinates elevation should be extracted\n  heights <- seq(ex[\"ymin\"], ex[\"ymax\"], vspace)\n  \n  # calculates the x/y coordinates to extract points from the dhm\n  mypoints_mat <- map(heights, function(height){\n    matrix(c(ex[\"xmin\"], height, ex[\"xmax\"], height), ncol = 2, byrow = TRUE) %>%\n      st_linestring()\n  }) %>%\n    st_as_sfc() %>%\n    st_line_sample(density = point_density,type = \"regular\") %>%\n    st_as_sf() %>%\n    st_cast(\"POINT\") %>%\n    st_coordinates()\n  \n  \n  # extracts the elevation from the dhm\n  extracted <- terra::extract(dhm, mypoints_mat) %>% \n    cbind(mypoints_mat) %>% \n    as_tibble()\n  \n  # calculates the factor with which to multiply elevation, based on \"fac\" and the maximum elevation value\n  fac <- vspace*fac/max(extracted[,1], na.rm = TRUE)\n  \n  # calculates the coordinats of the ridge lines\n  coords <-extracted %>%\n    filter(!is.na(extracted[,1])) %>%\n    split(.$Y) %>%\n    imap(function(df, hig){\n      hig <- as.numeric(hig)\n      Y_new <- hig+pull(df[,1])*fac\n      matrix(c(df$X, Y_new), ncol = 2)\n    })\n\n  # creates LINESTRING or POLYGON, based on the \"geom_type\"\n  geoms <- if(geom_type == \"LINESTRING\"){\n    map(coords, ~st_linestring(.x))\n  } else if(geom_type == \"POLYGON\"){\n    imap(coords, function(x, hig){\n      hig <- as.numeric(hig)\n      \n      first <- head(x, 1)\n      first[,2] <- hig\n      last <- tail(x, 1)\n      last[,2] <- hig\n      \n      st_polygon(list(rbind(first, x, last, first)))\n    })\n  } else{\n    stop(paste0(\"This geom_type is not implemented:\",geom_type,\". geom_type must be 'LINESTRING' or 'POLYGON'\"))\n  }\n  \n  # adds the CRS to the output sfc\n  dhm_crs <- crs(dhm)\n  \n  if(dhm_crs == \"\") warning(\"dhm does not seem to have a CRS, therefore the output does not have a CRS assigned either.\")\n  \n  geoms %>%\n    st_sfc() %>%\n    st_set_crs(dhm_crs)\n  \n}\n\n# A helper function to creteate a polygon from the extent of a (dhm) raster\nst_bbox_rast <- function(rast_obj){\n  \n  library(terra)\n  library(sf)\n  \n  ex <- ext(dhm) %>%\n    as.vector()\n  \n  matrix(c(ex[1],ex[3],ex[1], ex[4],ex[2], ex[4],ex[2],ex[3],ex[1],ex[3]),ncol = 2, byrow = TRUE) %>%\n  list() %>%\n  st_polygon() %>% \n    st_sfc(crs = crs(rast_obj))\n}\n\n\n\nImport data and use the functions\n\n\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(ragg)\n\n\ndhm <- terra::rast(\"data-git-lfs/DHM25/DHM200.asc\")\ncrs(dhm) <- \"epsg:21781\"\n\n\nswitzerland_21781 <- sf::read_sf(\"data-git-lfs/swissboundaries/swissBOUNDARIES3D_1_3_TLM_LANDESGEBIET.shp\") %>%\n  st_union() %>%\n  st_transform(21781) \n\nmymask <- st_bbox_rast(dhm) %>%\n  st_buffer(5000) %>%\n  st_difference(switzerland_21781)\n\n\n\n\n\nsf_obj <- create_ridges(dhm,n_lines = 35, fac = 1.1,geom_type = \"POLYGON\")\n\nbg_color <- \"#27363B\"\nfg_color <- \"#EB4960\"\nfamily <- \"FreeMono\"\n\n\n\n\nbbox_switz <- st_bbox(switzerland_21781)\nbbox_switz_enlarge <- st_buffer(st_as_sfc(bbox_switz),50000)\nlims <- st_bbox(bbox_switz_enlarge)\nxlims =  lims[c(\"xmin\",\"xmax\")]\nylims = lims[c(\"ymin\",\"ymax\")]\n\nasp <- diff(ylims)/diff(xlims)\n\n\n\n\n\nmyplot <- ggplot(sf_obj) +\n  geom_sf(color = \"NA\", fill = fg_color)  + \n  geom_sf(data = mymask, color = \"NA\", fill = bg_color) +\n  # geom_sf(data = bbox_switz_enlarge, fill = \"NA\") +\n  ggtext::geom_richtext(aes(x = median(xlims), y = quantile(ylims,0.95), label = \"Topography of Switzerland\"), family = family, fill = NA, label.color = NA, hjust = 0.5, size = 6, color = fg_color)+\n  ggtext::geom_richtext(aes(x = median(xlims), y = ylims[\"ymin\"], label = \"Data from ©swisstopo<br>visualized by Nils Ratnaweera\"), family = family, fill = NA, label.color = NA, hjust = 0.5, size = 3.5, color = fg_color)+\n  theme_void() +\n  theme(plot.background = element_rect(fill = bg_color,color = NA)) +\n  coord_sf(datum = 21781,xlim =  xlims, ylim = ylims);\n\nmyplot\n\n\n\nggsave(\"minimalistic_topography.png\", myplot,dpi = 600, device = agg_png, width = 15, units = \"cm\")\n\n\n\n\nOriginal (Esp): “Tan linda que duele.”↩︎\n",
    "preview": "posts/2021-08-13-minimalistic-topography/minimalistic_topography.png",
    "last_modified": "2021-08-18T21:45:14+02:00",
    "input_file": {},
    "preview_width": 3543,
    "preview_height": 2787
  }
]
